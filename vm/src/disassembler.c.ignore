#include <stdint.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "common.h"
#include "vm.h"

static uint32_t ip = 0;

char *registersflip[MAX_REGS + 1] = {
    "n/a",
    "ax",
    "bx",
    "cx",
    "dx",
    "si",
    "di",
    "sp",
    "bp",
    "ip",
    "r8",
    "r9",
    "r10",
    "r11",
    "r12",
    "r13",
    "r14",
    "r15"
};

uint8_t DIS_READ_BYTE(uint8_t *source) {
    return source[ip++];
}

uint16_t DIS_READ_BYTE16(uint8_t *source) {
    return (DIS_READ_BYTE(source) << 8) | DIS_READ_BYTE(source);
}

uint32_t DIS_READ_BYTE32(uint8_t *source) {
    return (DIS_READ_BYTE16(source) << 16) + DIS_READ_BYTE16(source);
}

static void disasm_mov(uint8_t instruction, uint8_t mode, uint8_t *buffer) {

    switch(mode) {
        case 0x00: // REGREG
            printf("mov %s, %s\n", registersflip[DIS_READ_BYTE(buffer)], registersflip[DIS_READ_BYTE(buffer)]);
            break;
        case 0x01: // REGPTR
            break;
        case 0x02: // REGDAT
            printf("mov %s, 0x%08x\n", registersflip[DIS_READ_BYTE(buffer)], DIS_READ_BYTE32(buffer));
            break;
        case 0x03: // PTRREG
            break;
        case 0x04: // PTRDAT
            break;
        case 0x05: // PTRPTR
            break;
    }
}

void disasm(uint8_t *buffer, size_t size) {
    ip = 2;

    while(ip < size) {
        uint8_t instruction = DIS_READ_BYTE(buffer);
        uint8_t mode = DIS_READ_BYTE(buffer);

        switch(instruction) {
            case OP_HALT:
                printf("halt\n");
                break;
            case OP_NOOP:
                printf("noop\n");
                break;
            case OP_MOV:
                disasm_mov(instruction, mode, buffer);
                break;
        }
    }
}